<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>월별 일정관리</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; }
        h1, h3 { color: #333; }
        .form, .schedule-list, .holiday-list { text-align: left; max-width: 400px; margin: 20px auto; padding: 15px; background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .form label, .form input, .form select, .form button { margin: 5px; }
        .form button, .schedule-list button, .holiday-list button { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer; }
        .form button:hover, .schedule-list button:hover, .holiday-list button:hover { background-color: #45a049; }
        a { text-decoration: none; color: #4CAF50; }
        a:hover { color: #45a049; }
        .schedule-list div, .holiday-list div { margin: 10px 0; }
        .schedule-list input { width: 100px; }
        .note { font-size: 12px; color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>GOGCC - 일정 및 공휴일 관리</h1>
        <a href="index.html">달력으로 돌아가기</a>
        <div class="form">
            <h3>일정 추가</h3>
            <p class="note">일정은 브라우저에 자동 저장됩니다.<br>
            - 평일: 주말/공휴일 제외, 평일만 카운팅.<br>
            - 주말/공휴일: 주말과 공휴일만 카운팅.<br>
            - 둘 다: 모든 날 연속 카운팅.<br>
            - 새 공휴일 추가 시 평일 일정은 자동 미뤄집니다.</p>
            <label>일정 제목: <input type="text" id="scheduleName" placeholder="예: 프로젝트 A"></label><br>
            <label>시작 날짜: <input type="date" id="startDate" value="2025-05-16"></label><br>
            <label>종료 날짜: <input type="date" id="endDate" value="2026-03-31"></label><br>
            <label>대상: 
                <select id="dayType">
                    <option value="weekday">평일 (월~금)</option>
                    <option value="all">둘 다 (월~일)</option>
                    <option value="weekend">주말/공휴일</option>
                </select>
            </label><br>
            <label>반복 주기 (일): <input type="number" id="cycleDays" value="13" min="1" placeholder="예: 13"></label><br>
            <label>유지 일수: <input type="number" id="durationDays" value="3" min="1" placeholder="예: 3"></label><br>
            <label>일정 내용: <input type="text" id="eventTitle" placeholder="예: 5T"></label><br>
            <button onclick="handleSchedule()">일정 추가</button>
        </div>
        <div class="form">
            <h3>공휴일 관리</h3>
            <p class="note">기본 공휴일은 읽기 전용이며, 사용자 정의 공휴일은 추가/삭제 가능합니다.<br>
            새 공휴일 추가 시 기존 평일 일정은 자동으로 조정됩니다.</p>
            <label>연도: <select id="year"></select></label>
            <button onclick="loadHolidays()">공휴일 불러오기</button><br>
            <label>사용자 정의 공휴일 추가</label><br>
            <label>공휴일 날짜: <input type="date" id="holidayDate"></label><br>
            <label>공휴일 이름: <input type="text" id="holidayName" placeholder="예: 선거일"></label><br>
            <button onclick="addHoliday()">공휴일 추가</button>
        </div>
        <div class="schedule-list" id="scheduleList">
            <h3>등록된 일정</h3>
        </div>
        <div class="holiday-list" id="holidayList">
            <h3>등록된 공휴일</h3>
        </div>
    </div>

    <script>
        let events = JSON.parse(localStorage.getItem('events')) || {};
        let customHolidays = JSON.parse(localStorage.getItem('custom_holidays')) || {};

        // 공휴일 데이터를 GitHub에서 가져오기
        async function fetchHolidays(year) {
            try {
                const response = await fetch(`https://holidays.hyunbin.page/${year}.json`);
                if (!response.ok) throw new Error('Failed to fetch holidays');
                const data = await response.json();
                localStorage.setItem(`holidays_${year}`, JSON.stringify(data));
                return data;
            } catch (error) {
                console.error('Error fetching holidays:', error);
                return JSON.parse(localStorage.getItem(`holidays_${year}`)) || {};
            }
        }

        // 공휴일과 사용자 정의 공휴일 병합
        function mergeHolidays(year) {
            const fetchedHolidays = JSON.parse(localStorage.getItem(`holidays_${year}`)) || {};
            const custom = JSON.parse(localStorage.getItem('custom_holidays')) || {};
            return { ...fetchedHolidays, ...custom };
        }

        // 연도 선택 드롭다운 초기화
        const yearSelect = document.getElementById('year');
        for (let y = 2025; y <= 2026; y++) {
            yearSelect.innerHTML += `<option value="${y}" ${y === new Date().getFullYear() ? 'selected' : ''}>${y}</option>`;
        }

        // 공휴일 표시
        async function loadHolidays() {
            const year = yearSelect.value;
            const holidays = await fetchHolidays(year);
            const mergedHolidays = mergeHolidays(year);
            let html = '<h3>등록된 공휴일</h3>';
            const sortedDates = Object.keys(mergedHolidays).sort();
            for (let date of sortedDates) {
                const isCustom = date in customHolidays;
                html += `<div>${date}: ${mergedHolidays[date]} ${isCustom ? `<button onclick="deleteHoliday('${date}')">삭제</button>` : '(기본)'}</div>`;
            }
            document.getElementById('holidayList').innerHTML = html;
        }

        function isValidDay(date, dayType) {
            const dateStr = date.toISOString().split('T')[0];
            const mergedHolidays = mergeHolidays(date.getFullYear());
            if (dayType === 'weekday') {
                return date.getDay() !== 0 && date.getDay() !== 6 && !(dateStr in mergedHolidays);
            }
            if (dayType === 'weekend') {
                return (date.getDay() === 0 || date.getDay() === 6 || (dateStr in mergedHolidays));
            }
            return true;
        }

        function addSchedule(scheduleName, startDate, endDate, dayType, cycleDays, durationDays, eventTitle) {
            if (!events[scheduleName]) events[scheduleName] = [];
            let currentDate = new Date(startDate);
            let cycleCount = 0;

            while (currentDate <= endDate) {
                if (isValidDay(currentDate, dayType)) {
                    let validDaysAdded = 0;
                    while (validDaysAdded < durationDays && currentDate <= endDate) {
                        if (isValidDay(currentDate, dayType)) {
                            const dateStr = currentDate.toISOString().split('T')[0];
                            events[scheduleName].push({ date: dateStr, title: eventTitle });
                            validDaysAdded++;
                        }
                        currentDate.setDate(currentDate.getDate() + 1);
                    }
                    if (validDaysAdded < durationDays) break;

                    if (dayType === 'all') {
                        currentDate.setDate(currentDate.getDate() - validDaysAdded + cycleDays);
                    } else {
                        let validCycleDays = 0;
                        while (validCycleDays < cycleDays && currentDate <= endDate) {
                            if (isValidDay(currentDate, dayType)) {
                                validCycleDays++;
                            }
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                    }
                    cycleCount++;
                    if (cycleCount > 1000) {
                        console.error('무한 루프 방지: 최대 1000 사이클');
                        break;
                    }
                } else {
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            }
        }

        function reprocessSchedules() {
            const originalEvents = { ...events };
            events = {};
            for (let scheduleName in originalEvents) {
                const scheduleEvents = originalEvents[scheduleName];
                if (scheduleEvents.length === 0) continue;

                const firstEvent = scheduleEvents[0];
                const startDate = new Date(firstEvent.date);
                const eventTitle = firstEvent.title;
                const lastEvent = scheduleEvents[scheduleEvents.length - 1];
                const endDate = new Date(lastEvent.date);

                let cycleDays = 16;
                let durationDays = 1;
                let dayType = 'weekday';

                const dates = scheduleEvents.map(e => new Date(e.date)).sort((a, b) => a - b);
                for (let i = 1; i < dates.length; i++) {
                    const diff = (dates[i] - dates[i - 1]) / (1000 * 60 * 60 * 24);
                    if (diff > 1) {
                        cycleDays = Math.min(cycleDays, diff);
                    }
                }
                durationDays = scheduleEvents.filter(e => new Date(e.date).getTime() <= dates[0].getTime() + durationDays * 24 * 60 * 60 * 1000).length;

                if (scheduleEvents.every(e => {
                    const date = new Date(e.date);
                    return date.getDay() === 0 || date.getDay() === 6 || (e.date in mergeHolidays(date.getFullYear()));
                })) {
                    dayType = 'weekend';
                } else if (scheduleEvents.every(e => {
                    const date = new Date(e.date);
                    return !(date.getDay() === 0 || date.getDay() === 6 || (e.date in mergeHolidays(date.getFullYear())));
                })) {
                    dayType = 'weekday';
                } else {
                    dayType = 'all';
                }

                addSchedule(scheduleName, startDate, endDate, dayType, cycleDays, durationDays, eventTitle);
            }
            localStorage.setItem('events', JSON.stringify(events));
            displaySchedules();
        }

        function handleSchedule() {
            const scheduleName = document.getElementById('scheduleName').value.trim();
            const startDateInput = document.getElementById('startDate').value;
            const endDateInput = document.getElementById('endDate').value;
            const dayType = document.getElementById('dayType').value;
            const cycleDaysInput = document.getElementById('cycleDays').value;
            const durationDaysInput = document.getElementById('durationDays').value;
            const eventTitle = document.getElementById('eventTitle').value.trim();

            // 입력값 검증
            if (!scheduleName || !eventTitle) {
                alert('일정 제목과 내용을 입력하세요.');
                return;
            }
            if (!startDateInput || !endDateInput) {
                alert('시작 날짜와 종료 날짜를 입력하세요.');
                return;
            }
            const startDate = new Date(startDateInput);
            const endDate = new Date(endDateInput);
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
                alert('유효한 날짜 형식을 입력하세요.');
                return;
            }
            if (startDate > endDate) {
                alert('종료 날짜는 시작 날짜보다 늦어야 합니다.');
                return;
            }
            const cycleDays = parseInt(cycleDaysInput);
            const durationDays = parseInt(durationDaysInput);
            if (isNaN(cycleDays) || isNaN(durationDays) || cycleDays < 1 || durationDays < 1) {
                alert('반복 주기와 유지 일수는 1 이상의 숫자를 입력하세요.');
                return;
            }

            addSchedule(scheduleName, startDate, endDate, dayType, cycleDays, durationDays, eventTitle);
            localStorage.setItem('events', JSON.stringify(events));
            displaySchedules();
            alert('일정이 추가되었습니다.');
        }

        function addHoliday() {
            const holidayDate = document.getElementById('holidayDate').value;
            const holidayName = document.getElementById('holidayName').value.trim();
            if (!holidayDate || !holidayName) {
                alert('공휴일 날짜와 이름을 입력하세요.');
                return;
            }
            customHolidays[holidayDate] = holidayName;
            localStorage.setItem('custom_holidays', JSON.stringify(customHolidays));
            reprocessSchedules();
            loadHolidays();
            alert('사용자 정의 공휴일이 추가되었습니다. 기존 평일 일정이 조정되었습니다.');
        }

        function displaySchedules() {
            const scheduleList = document.getElementById('scheduleList');
            let html = '<h3>등록된 일정</h3>';
            for (let schedule in events) {
                html += `<div>
                    <strong>${schedule}</strong>
                    <button onclick="deleteSchedule('${schedule}')">삭제</button>
                    <ul>`;
                events[schedule].forEach((event, index) => {
                    html += `<li>
                        ${event.date}: <input type="text" value="${event.title}" onchange="editSchedule('${schedule}', ${index}, this.value)">
                    </li>`;
                });
                html += '</ul></div>';
            }
            scheduleList.innerHTML = html;
        }

        function deleteSchedule(scheduleName) {
            if (confirm(`'${scheduleName}' 일정을 삭제하시겠습니까?`)) {
                delete events[scheduleName];
                localStorage.setItem('events', JSON.stringify(events));
                displaySchedules();
            }
        }

        function editSchedule(scheduleName, index, newTitle) {
            if (newTitle.trim()) {
                events[scheduleName][index].title = newTitle.trim();
                localStorage.setItem('events', JSON.stringify(events));
                displaySchedules();
            }
        }

        function deleteHoliday(date) {
            if (confirm(`'${customHolidays[date]}' 사용자 정의 공휴일을 삭제하시겠습니까?`)) {
                delete customHolidays[date];
                localStorage.setItem('custom_holidays', JSON.stringify(customHolidays));
                reprocessSchedules();
                loadHolidays();
            }
        }

        window.addEventListener('load', async () => {
            events = JSON.parse(localStorage.getItem('events')) || {};
            customHolidays = JSON.parse(localStorage.getItem('custom_holidays')) || {};
            await fetchHolidays(yearSelect.value);
            loadHolidays();
            displaySchedules();
        });

        yearSelect.addEventListener('change', loadHolidays);
    </script>
</body>
</html>
