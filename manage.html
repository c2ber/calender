<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>월별 일정관리</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; padding: 20px; background-color: #f5f5f5; }
        .container { max-width: 800px; margin: 0 auto; }
        h1, h3 { color: #333; }
        .form, .schedule-list, .holiday-list { text-align: left; max-width: 400px; margin: 20px auto; padding: 15px; background-color: white; border-radius: 5px; box-shadow: 0 2px 5px rgba(0,0,0,0.1); }
        .form label, .form input, .form select, .form button { margin: 5px; }
        .form button, .schedule-list button, .holiday-list button { background-color: #4CAF50; color: white; border: none; padding: 8px 16px; border-radius: 3px; cursor: pointer; }
        .form button:hover, .schedule-list button:hover, .holiday-list button:hover { background-color: #45a049; }
        a { text-decoration: none; color: #4CAF50; }
        a:hover { color: #45a049; }
        .schedule-list div, .holiday-list div { margin: 10px 0; }
        .schedule-list input { width: 100px; }
        .note { font-size: 12px; color: #555; }
    </style>
</head>
<body>
    <div class="container">
        <h1>월별 일정관리</h1>
        <a href="index.html">달력으로 돌아가기</a>
        <div class="form">
            <h3>일정 추가</h3>
            <p class="note">일정은 브라우저에 자동 저장됩니다.<br>
            - 평일: 주말/공휴일 제외<br>
            - 주말/공휴일: 주말과 공휴일만<br>
            - 둘 다: 모든 날 연속<br>
            - 새 공휴일 추가 시 공휴일 이후부터 조정</p>
            <label>일정 제목: <input type="text" id="scheduleName" placeholder="예: 프로젝트 A"></label><br>
            <label>시작 날짜: <input type="date" id="startDate" value="2025-05-16"></label><br>
            <label>종료 날짜: <input type="date" id="endDate" value="2026-03-31"></label><br>
            <label>대상: 
                <select id="dayType">
                    <option value="weekday">평일 (월~금)</option>
                    <option value="all">둘 다 (월~일)</option>
                    <option value="weekend">주말/공휴일</option>
                </select>
            </label><br>
            <label>반복 주기 (일): <input type="number" id="cycleDays" value="13" min="1" placeholder="예: 13"></label><br>
            <label>유지 일수: <input type="number" id="durationDays" value="3" min="1" placeholder="예: 3"></label><br>
            <label>일정 내용: <input type="text" id="eventTitle" placeholder="예: 5T"></label><br>
            <button onclick="handleSchedule()">일정 추가</button>
        </div>
        <div class="form">
            <h3>공휴일 관리</h3>
            <p class="note">기본 공휴일은 읽기 전용, 사용자 정의 공휴일은 추가/삭제 가능</p>
            <label>연도: <select id="year"></select></label><br>
            <label>사용자 정의 공휴일 추가</label><br>
            <label>공휴일 날짜: <input type="date" id="holidayDate"></label><br>
            <label>공휴일 이름: <input type="text" id="holidayName" placeholder="예: 선거일"></label><br>
            <button onclick="addHoliday()">공휴일 추가</button>
        </div>
        <div class="schedule-list" id="scheduleList">
            <h3>등록된 일정</h3>
        </div>
        <div class="holiday-list" id="holidayList">
            <h3>등록된 공휴일</h3>
        </div>
    </div>

    <script>
        const today = new Date();
        let events = JSON.parse(localStorage.getItem('events')) || {};
        let customHolidays = JSON.parse(localStorage.getItem('custom_holidays')) || {};

        // 공휴일 데이터 가져오기
        async function fetchHolidays(year) {
            try {
                const response = await fetch(`holidays_${year}.json`);
                if (!response.ok) throw new Error('Failed to fetch holidays');
                const data = await response.json();
                localStorage.setItem(`holidays_${year}`, JSON.stringify(data));
                return data;
            } catch (error) {
                console.error('Error fetching holidays:', error);
                return JSON.parse(localStorage.getItem(`holidays_${year}`)) || {};
            }
        }

        // 공휴일과 사용자 정의 공휴일 병합
        function mergeHolidays(year) {
            const fetchedHolidays = JSON.parse(localStorage.getItem(`holidays_${year}`)) || {};
            const custom = JSON.parse(localStorage.getItem('custom_holidays')) || {};
            return { ...fetchedHolidays, ...custom };
        }

        // 연도 선택 초기화
        const yearSelect = document.getElementById('year');
        for (let y = today.getFullYear(); y <= today.getFullYear() + 2; y++) {
            yearSelect.innerHTML += `<option value="${y}" ${y === today.getFullYear() ? 'selected' : ''}>${y}</option>`;
        }

        // 공휴일 표시
        async function loadHolidays() {
            const year = yearSelect.value;
            await fetchHolidays(year);
            const mergedHolidays = mergeHolidays(year);
            let html = '<h3>등록된 공휴일</h3>';
            Object.keys(mergedHolidays).sort().forEach(date => {
                const isCustom = date in customHolidays;
                html += `<div>${date}: ${mergedHolidays[date]} ${isCustom ? `<button onclick="deleteHoliday('${date}')">삭제</button>` : '(기본)'}</div>`;
            });
            document.getElementById('holidayList').innerHTML = html;
        }

        // 유효한 날짜 확인
        function isValidDay(date, dayType) {
            const dateStr = date.toISOString().split('T')[0];
            const mergedHolidays = mergeHolidays(date.getFullYear());
            if (dayType === 'weekday') return date.getDay() !== 0 && date.getDay() !== 6 && !(dateStr in mergedHolidays);
            if (dayType === 'weekend') return date.getDay() === 0 || date.getDay() === 6 || dateStr in mergedHolidays;
            return true;
        }

        // 다음 유효 날짜 찾기
        function findNextValidDate(startDate, dayType) {
            let nextDate = new Date(startDate);
            nextDate.setDate(nextDate.getDate() + 1);
            while (!isValidDay(nextDate, dayType) && nextDate <= new Date('2030-12-31')) {
                nextDate.setDate(nextDate.getDate() + 1);
            }
            return nextDate;
        }

        // 일정 추가
        function addSchedule(scheduleName, startDate, endDate, dayType, cycleDays, durationDays, eventTitle, resumeDate = null) {
            if (!events[scheduleName]) {
                events[scheduleName] = {
                    metadata: { startDate, endDate, dayType, cycleDays, durationDays, eventTitle },
                    dates: []
                };
            }
            let currentDate = resumeDate ? new Date(resumeDate) : new Date(startDate);
            let cycleCount = 0;
            let expectedDates = [];

            while (currentDate <= endDate) {
                if (isValidDay(currentDate, dayType)) {
                    let validDaysAdded = 0;
                    let tempDate = new Date(currentDate);
                    let cycleDates = [];
                    while (validDaysAdded < durationDays && tempDate <= endDate) {
                        if (isValidDay(tempDate, dayType)) {
                            const dateStr = tempDate.toISOString().split('T')[0];
                            cycleDates.push({ date: dateStr, title: eventTitle });
                            validDaysAdded++;
                        }
                        tempDate = findNextValidDate(tempDate, dayType);
                    }
                    if (validDaysAdded < durationDays) break;
                    events[scheduleName].dates.push(...cycleDates);
                    expectedDates.push(cycleDates[0].date);
                    // 다음 주기 계산
                    currentDate.setDate(currentDate.getDate() + cycleDays);
                    if (dayType !== 'all') {
                        while (!isValidDay(currentDate, dayType) && currentDate <= endDate) {
                            currentDate.setDate(currentDate.getDate() + 1);
                        }
                    }
                    cycleCount++;
                    if (cycleCount > 1000) {
                        console.error('무한 루프 방지: 최대 1000 사이클');
                        break;
                    }
                } else {
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            }

            // 주기 간격 디버깅
            console.log(`Added schedule: ${scheduleName}, cycleDays: ${cycleDays}`);
            console.log('Expected dates:', expectedDates);
            if (expectedDates.length > 1) {
                expectedDates.forEach((date, i) => {
                    if (i > 0) {
                        const diff = (new Date(date) - new Date(expectedDates[i-1])) / (1000 * 60 * 60 * 24);
                        console.log(`Cycle ${i}: ${expectedDates[i-1]} -> ${date} (${diff} days)`);
                    }
                });
            }
        }

        // 일정 재조정
        function reprocessSchedules(holidayDate) {
            const originalEvents = { ...events };
            events = {};

            for (let scheduleName in originalEvents) {
                const metadata = originalEvents[scheduleName].metadata;
                if (!metadata) {
                    console.warn(`No metadata for ${scheduleName}, skipping reprocess`);
                    continue;
                }
                console.log(`Reprocessing ${scheduleName} from ${holidayDate}:`, metadata);

                // 공휴일 이전 일정 유지
                events[scheduleName] = {
                    metadata: { ...metadata },
                    dates: originalEvents[scheduleName].dates.filter(event => event.date < holidayDate)
                };

                // 공휴일 이후 일정 재조정
                if (holidayDate <= metadata.endDate) {
                    const beforeHolidayDates = originalEvents[scheduleName].dates
                        .filter(event => event.date < holidayDate)
                        .sort((a, b) => new Date(b.date) - new Date(a.date));
                    let resumeDate = holidayDate;
                    if (beforeHolidayDates.length > 0) {
                        const lastEventDate = new Date(beforeHolidayDates[0].date);
                        // 마지막 유지 일정의 끝에서 주기 시작
                        resumeDate = new Date(lastEventDate);
                        resumeDate.setDate(resumeDate.getDate() + metadata.cycleDays - metadata.durationDays + 1);
                        if (metadata.dayType !== 'all') {
                            while (!isValidDay(resumeDate, metadata.dayType) && resumeDate <= metadata.endDate) {
                                resumeDate.setDate(resumeDate.getDate() + 1);
                            }
                        }
                    }
                    if (resumeDate <= metadata.endDate) {
                        addSchedule(
                            scheduleName,
                            metadata.startDate,
                            metadata.endDate,
                            metadata.dayType,
                            metadata.cycleDays,
                            metadata.durationDays,
                            metadata.eventTitle,
                            resumeDate
                        );
                    }
                }

                // 날짜 정렬
                events[scheduleName].dates.sort((a, b) => new Date(a.date) - new Date(b.date));
            }

            localStorage.setItem('events', JSON.stringify(events));
            displaySchedules();
            console.log('Reprocessed schedules:', events);
        }

        // 일정 추가 처리
        function handleSchedule() {
            const scheduleName = document.getElementById('scheduleName').value.trim();
            const startDateInput = document.getElementById('startDate').value;
            const endDateInput = document.getElementById('endDate').value;
            const dayType = document.getElementById('dayType').value;
            const cycleDays = parseInt(document.getElementById('cycleDays').value);
            const durationDays = parseInt(document.getElementById('durationDays').value);
            const eventTitle = document.getElementById('eventTitle').value.trim();

            if (!scheduleName || !eventTitle) return alert('일정 제목과 내용을 입력하세요.');
            if (!startDateInput || !endDateInput) return alert('시작 날짜와 종료 날짜를 입력하세요.');
            const startDate = new Date(startDateInput);
            const endDate = new Date(endDateInput);
            if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) return alert('유효한 날짜 형식을 입력하세요.');
            if (startDate > endDate) return alert('종료 날짜는 시작 날짜보다 늦어야 합니다.');
            if (isNaN(cycleDays) || isNaN(durationDays) || cycleDays < 1 || durationDays < 1) {
                return alert('반복 주기와 유지 일수는 1 이상의 숫자를 입력하세요.');
            }

            addSchedule(scheduleName, startDate, endDate, dayType, cycleDays, durationDays, eventTitle);
            localStorage.setItem('events', JSON.stringify(events));
            displaySchedules();
            alert('일정이 추가되었습니다.');
        }

        // 공휴일 추가
        function addHoliday() {
            const holidayDate = document.getElementById('holidayDate').value;
            const holidayName = document.getElementById('holidayName').value.trim();
            if (!holidayDate || !holidayName) return alert('공휴일 날짜와 이름을 입력하세요.');
            customHolidays[holidayDate] = holidayName;
            localStorage.setItem('custom_holidays', JSON.stringify(customHolidays));
            reprocessSchedules(holidayDate);
            loadHolidays();
            alert('사용자 정의 공휴일이 추가되었습니다. 공휴일 이후 평일 일정이 조정되었습니다.');
        }

        // 일정 표시
        function displaySchedules() {
            const scheduleList = document.getElementById('scheduleList');
            let html = '<h3>등록된 일정</h3>';
            for (let schedule in events) {
                html += `<div><strong>${schedule}</strong> <button onclick="deleteSchedule('${schedule}')">삭제</button><ul>`;
                events[schedule].dates.forEach((event, index) => {
                    html += `<li>${event.date}: <input type="text" value="${event.title}" onchange="editSchedule('${schedule}', ${index}, this.value)"></li>`;
                });
                html += '</ul></div>';
            }
            scheduleList.innerHTML = html;
        }

        // 일정 삭제
        function deleteSchedule(scheduleName) {
            if (confirm(`'${scheduleName}' 일정을 삭제하시겠습니까?`)) {
                delete events[scheduleName];
                localStorage.setItem('events', JSON.stringify(events));
                displaySchedules();
            }
        }

        // 일정 수정
        function editSchedule(scheduleName, index, newTitle) {
            if (newTitle.trim()) {
                events[scheduleName].dates[index].title = newTitle.trim();
                localStorage.setItem('events', JSON.stringify(events));
                displaySchedules();
            }
        }

        // 공휴일 삭제
        function deleteHoliday(date) {
            if (confirm(`'${customHolidays[date]}' 사용자 정의 공휴일을 삭제하시겠습니까?`)) {
                delete customHolidays[date];
                localStorage.setItem('custom_holidays', JSON.stringify(customHolidays));
                reprocessSchedules(date);
                loadHolidays();
            }
        }

        // 초기화 및 이벤트 리스너
        window.addEventListener('load', async () => {
            events = JSON.parse(localStorage.getItem('events')) || {};
            customHolidays = JSON.parse(localStorage.getItem('custom_holidays')) || {};
            await fetchHolidays(yearSelect.value);
            loadHolidays();
            displaySchedules();
        });
        yearSelect.addEventListener('change', loadHolidays);
    </script>
</body>
</html>
